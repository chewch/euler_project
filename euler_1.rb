require 'pry'
require 'pry-nav'
require 'prime'

# Mult of 3 and 5
# If we list all the natural numbers below 10 that are multiples
# of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.
def euler1
  sum = 0;

  1..1000.times do |x|
    y = x + 1
    if x % 3 == 0 || x % 5 == 0
      sum = sum + x
    end
  end

  puts sum
end

# Fibonacci even #
# Each new term in the Fibonacci sequence is generated by adding
# the previous two terms. By starting with 1 and 2, the first 10
# terms will be:
#     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values
# do not exceed four million, find the sum of the even-valued terms.
def euler2
  fibs = [1, 2]
  sum = 2
  fn = 0

  while fn < 4000000

    fn = fibs[fibs.length-1] + fibs[fibs.length-2]
    fibs.push(fn)

    if fn % 2 == 0
      sum = sum + fn
    end

  end

end
#euler2

# def fib (num1, num2)
#   return num1 + num2
# end

# def re_fib
#   fibs = [1,2]
#   sum = 2
#   for i in 1..100
#     fn = fib(fibs.length-1, fibs.length-2)
#     fibs.push(fn)
#     if fn % 2 == 0
#       sum = sum + fn
#     end
#   end
#   p sum
# end
# re_fib

# Largest Prime Factor
# The prime factors of 13195 are 5, 7, 13 and 29.
# What is the largest prime factor of the number 600851475143 ?
def euler3
  largest_prime = 0

  Prime.each(300851475143) do |prime|
    if 600851475143 % prime == 0
      largest_prime = prime
      p largest_prime
    end
  end
end
#euler3

# Largest Palindrome Product

# A palindromic number reads the same both ways. The largest
# palindrome made from the product of two 2-digit numbers is
# 9009 = 91 Ã— 99.
# Find the largest palindrome made from the product of two
# 3-digit numbers.
def euler4
  largest_pd = 0
  for i in 100..999
    for j in 100..999
      k = i * j

      k_s = k.to_s
      sl = k_s.length
      if k_s % 2 == 0
        if (k_s.slice(0, sl/2).reverse == k_s.slice(sl/2, sl)) && k > largest_pd
          largest_pd = k
          p i.to_s + "X" + j.to_s + "=" + k.to_s
        end
      else
        if (k_s.slice(0, sl/2).reverse == k_s.slice(sl/2+1, sl)) && k > largest_pd
          largest_pd = k
          p i.to_s + "X" + j.to_s + "=" + k.to_s
        end
      end
    end
  end
end
euler4